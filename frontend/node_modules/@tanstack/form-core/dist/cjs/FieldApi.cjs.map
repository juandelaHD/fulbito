{"version":3,"file":"FieldApi.cjs","sources":["../../src/FieldApi.ts"],"sourcesContent":["import { Derived, batch } from '@tanstack/store'\nimport {\n  isStandardSchemaValidator,\n  standardSchemaValidators,\n} from './standardSchemaValidator'\nimport { defaultFieldMeta } from './metaHelper'\nimport { getAsyncValidatorArray, getBy, getSyncValidatorArray } from './utils'\nimport type { DeepKeys, DeepValue, UnwrapOneLevelOfArray } from './util-types'\nimport type {\n  StandardSchemaV1,\n  StandardSchemaV1Issue,\n  TStandardSchemaValidatorValue,\n} from './standardSchemaValidator'\nimport type {\n  FieldInfo,\n  FormApi,\n  FormAsyncValidateOrFn,\n  FormValidateAsyncFn,\n  FormValidateFn,\n  FormValidateOrFn,\n} from './FormApi'\nimport type {\n  UpdateMetaOptions,\n  ValidationCause,\n  ValidationError,\n  ValidationErrorMap,\n} from './types'\nimport type { AsyncValidator, SyncValidator, Updater } from './utils'\n\n/**\n * @private\n */\n// TODO: Add the `Unwrap` type to the errors\ntype FieldErrorMapFromValidator<\n  TFormData,\n  TName extends DeepKeys<TFormData>,\n  TData extends DeepValue<TFormData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TFormData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TFormData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TFormData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TFormData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TFormData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TFormData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TFormData, TName, TData>,\n> = Partial<\n  Record<\n    DeepKeys<TFormData>,\n    ValidationErrorMap<\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync\n    >\n  >\n>\n\n/**\n * @private\n */\nexport type FieldValidateFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> = (props: {\n  value: TData\n  fieldApi: FieldApi<\n    TParentData,\n    TName,\n    TData,\n    // This is technically an edge-type; which we try to keep non-`any`, but in this case\n    // It's referring to an inaccessible type from the field validate function inner types, so it's not a big deal\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  >\n}) => unknown\n\n/**\n * @private\n */\nexport type FieldValidateOrFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> =\n  | FieldValidateFn<TParentData, TName, TData>\n  | StandardSchemaV1<TData, unknown>\n\ntype StandardBrandedSchemaV1<T> = T & { __standardSchemaV1: true }\n\ntype UnwrapFormValidateOrFnForInner<\n  TValidateOrFn extends undefined | FormValidateOrFn<any>,\n> = [TValidateOrFn] extends [FormValidateFn<any>]\n  ? ReturnType<TValidateOrFn>\n  : [TValidateOrFn] extends [StandardSchemaV1<infer TOut, any>]\n    ? StandardBrandedSchemaV1<TOut>\n    : undefined\n\nexport type UnwrapFieldValidateOrFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TValidateOrFn extends undefined | FieldValidateOrFn<any, any, any>,\n  TFormValidateOrFn extends undefined | FormValidateOrFn<any>,\n> =\n  | ([TFormValidateOrFn] extends [StandardSchemaV1<any, infer TStandardOut>]\n      ? TName extends keyof TStandardOut\n        ? StandardSchemaV1Issue[]\n        : undefined\n      : undefined)\n  | (UnwrapFormValidateOrFnForInner<TFormValidateOrFn> extends infer TFormValidateVal\n      ? TFormValidateVal extends { __standardSchemaV1: true }\n        ? [DeepValue<TFormValidateVal, TName>] extends [never]\n          ? undefined\n          : StandardSchemaV1Issue[]\n        : TFormValidateVal extends { fields: any }\n          ? TName extends keyof TFormValidateVal['fields']\n            ? TFormValidateVal['fields'][TName]\n            : undefined\n          : undefined\n      : never)\n  | ([TValidateOrFn] extends [FieldValidateFn<any, any, any>]\n      ? ReturnType<TValidateOrFn>\n      : [TValidateOrFn] extends [StandardSchemaV1<any, any>]\n        ? // TODO: Check if `disableErrorFlat` is enabled, if so, return StandardSchemaV1Issue[][]\n          StandardSchemaV1Issue[]\n        : undefined)\n\n/**\n * @private\n */\nexport type FieldValidateAsyncFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> = (options: {\n  value: TData\n  fieldApi: FieldApi<\n    TParentData,\n    TName,\n    TData,\n    // This is technically an edge-type; which we try to keep non-`any`, but in this case\n    // It's referring to an inaccessible type from the field validate function inner types, so it's not a big deal\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  >\n  signal: AbortSignal\n}) => unknown | Promise<unknown>\n\n/**\n * @private\n */\nexport type FieldAsyncValidateOrFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> =\n  | FieldValidateAsyncFn<TParentData, TName, TData>\n  | StandardSchemaV1<TData, unknown>\n\ntype UnwrapFormAsyncValidateOrFnForInner<\n  TValidateOrFn extends undefined | FormAsyncValidateOrFn<any>,\n> = [TValidateOrFn] extends [FormValidateAsyncFn<any>]\n  ? Awaited<ReturnType<TValidateOrFn>>\n  : [TValidateOrFn] extends [StandardSchemaV1<infer TOut, any>]\n    ? StandardBrandedSchemaV1<TOut>\n    : undefined\n\nexport type UnwrapFieldAsyncValidateOrFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TValidateOrFn extends undefined | FieldAsyncValidateOrFn<any, any, any>,\n  TFormValidateOrFn extends undefined | FormAsyncValidateOrFn<any>,\n> =\n  | ([TFormValidateOrFn] extends [StandardSchemaV1<any, infer TStandardOut>]\n      ? TName extends keyof TStandardOut\n        ? StandardSchemaV1Issue[]\n        : undefined\n      : undefined)\n  | (UnwrapFormAsyncValidateOrFnForInner<TFormValidateOrFn> extends infer TFormValidateVal\n      ? TFormValidateVal extends { __standardSchemaV1: true }\n        ? [DeepValue<TFormValidateVal, TName>] extends [never]\n          ? undefined\n          : StandardSchemaV1Issue[]\n        : TFormValidateVal extends { fields: any }\n          ? TName extends keyof TFormValidateVal['fields']\n            ? TFormValidateVal['fields'][TName]\n            : undefined\n          : undefined\n      : never)\n  | ([TValidateOrFn] extends [FieldValidateAsyncFn<any, any, any>]\n      ? Awaited<ReturnType<TValidateOrFn>>\n      : [TValidateOrFn] extends [StandardSchemaV1<any, any>]\n        ? // TODO: Check if `disableErrorFlat` is enabled, if so, return StandardSchemaV1Issue[][]\n          StandardSchemaV1Issue[]\n        : undefined)\n\n/**\n * @private\n */\nexport type FieldListenerFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> = (props: {\n  value: TData\n  fieldApi: FieldApi<\n    TParentData,\n    TName,\n    TData,\n    // This is technically an edge-type; which we try to keep non-`any`, but in this case\n    // It's referring to an inaccessible type from the field listener function inner types, so it's not a big deal\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  >\n}) => void\n\nexport interface FieldValidators<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n> {\n  /**\n   * An optional function, that runs on the mount event of input.\n   */\n  onMount?: TOnMount\n  /**\n   * An optional function, that runs on the change event of input.\n   *\n   * @example z.string().min(1)\n   */\n  onChange?: TOnChange\n  /**\n   * An optional property similar to `onChange` but async validation\n   *\n   * @example z.string().refine(async (val) => val.length > 3, { message: 'Testing 123' })\n   */\n  onChangeAsync?: TOnChangeAsync\n  /**\n   * An optional number to represent how long the `onChangeAsync` should wait before running\n   *\n   * If set to a number larger than 0, will debounce the async validation event by this length of time in milliseconds\n   */\n  onChangeAsyncDebounceMs?: number\n  /**\n   * An optional list of field names that should trigger this field's `onChange` and `onChangeAsync` events when its value changes\n   */\n  onChangeListenTo?: DeepKeys<TParentData>[]\n  /**\n   * An optional function, that runs on the blur event of input.\n   *\n   * @example z.string().min(1)\n   */\n  onBlur?: TOnBlur\n  /**\n   * An optional property similar to `onBlur` but async validation.\n   *\n   * @example z.string().refine(async (val) => val.length > 3, { message: 'Testing 123' })\n   */\n  onBlurAsync?: TOnBlurAsync\n\n  /**\n   * An optional number to represent how long the `onBlurAsync` should wait before running\n   *\n   * If set to a number larger than 0, will debounce the async validation event by this length of time in milliseconds\n   */\n  onBlurAsyncDebounceMs?: number\n  /**\n   * An optional list of field names that should trigger this field's `onBlur` and `onBlurAsync` events when its value changes\n   */\n  onBlurListenTo?: DeepKeys<TParentData>[]\n  /**\n   * An optional function, that runs on the submit event of form.\n   *\n   * @example z.string().min(1)\n   */\n  onSubmit?: TOnSubmit\n  /**\n   * An optional property similar to `onSubmit` but async validation.\n   *\n   * @example z.string().refine(async (val) => val.length > 3, { message: 'Testing 123' })\n   */\n  onSubmitAsync?: TOnSubmitAsync\n}\n\nexport interface FieldListeners<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> {\n  onChange?: FieldListenerFn<TParentData, TName, TData>\n  onBlur?: FieldListenerFn<TParentData, TName, TData>\n  onMount?: FieldListenerFn<TParentData, TName, TData>\n  onSubmit?: FieldListenerFn<TParentData, TName, TData>\n}\n\n/**\n * An object type representing the options for a field in a form.\n */\nexport interface FieldOptions<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n> {\n  /**\n   * The field name. The type will be `DeepKeys<TParentData>` to ensure your name is a deep key of the parent dataset.\n   */\n  name: TName\n  /**\n   * An optional default value for the field.\n   */\n  defaultValue?: NoInfer<TData>\n  /**\n   * The default time to debounce async validation if there is not a more specific debounce time passed.\n   */\n  asyncDebounceMs?: number\n  /**\n   * If `true`, always run async validation, even if there are errors emitted during synchronous validation.\n   */\n  asyncAlways?: boolean\n  /**\n   * A list of validators to pass to the field\n   */\n  validators?: FieldValidators<\n    TParentData,\n    TName,\n    TData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync\n  >\n  /**\n   * An optional object with default metadata for the field.\n   */\n  defaultMeta?: Partial<\n    FieldMeta<\n      TParentData,\n      TName,\n      TData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any\n    >\n  >\n  /**\n   * A list of listeners which attach to the corresponding events\n   */\n  listeners?: FieldListeners<TParentData, TName, TData>\n  /**\n   * Disable the `flat(1)` operation on `field.errors`. This is useful if you want to keep the error structure as is. Not suggested for most use-cases.\n   */\n  disableErrorFlat?: boolean\n}\n\n/**\n * An object type representing the required options for the FieldApi class.\n */\nexport interface FieldApiOptions<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChangeAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnBlurAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnServer extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TParentSubmitMeta,\n> extends FieldOptions<\n    TParentData,\n    TName,\n    TData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync\n  > {\n  form: FormApi<\n    TParentData,\n    TFormOnMount,\n    TFormOnChange,\n    TFormOnChangeAsync,\n    TFormOnBlur,\n    TFormOnBlurAsync,\n    TFormOnSubmit,\n    TFormOnSubmitAsync,\n    TFormOnServer,\n    TParentSubmitMeta\n  >\n}\n\nexport type FieldMetaBase<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChangeAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnBlurAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n> = {\n  /**\n   * A flag indicating whether the field has been touched.\n   */\n  isTouched: boolean\n  /**\n   * A flag indicating whether the field has been blurred.\n   */\n  isBlurred: boolean\n  /**\n   * A flag that is `true` if the field's value has been modified by the user. Opposite of `isPristine`.\n   */\n  isDirty: boolean\n  /**\n   * A map of errors related to the field value.\n   */\n  errorMap: ValidationErrorMap<\n    UnwrapFieldValidateOrFn<TParentData, TName, TOnMount, TFormOnMount>,\n    UnwrapFieldValidateOrFn<TParentData, TName, TOnChange, TFormOnChange>,\n    UnwrapFieldAsyncValidateOrFn<\n      TParentData,\n      TName,\n      TOnChangeAsync,\n      TFormOnChangeAsync\n    >,\n    UnwrapFieldValidateOrFn<TParentData, TName, TOnBlur, TFormOnBlur>,\n    UnwrapFieldAsyncValidateOrFn<\n      TParentData,\n      TName,\n      TOnBlurAsync,\n      TFormOnBlurAsync\n    >,\n    UnwrapFieldValidateOrFn<TParentData, TName, TOnSubmit, TFormOnSubmit>,\n    UnwrapFieldAsyncValidateOrFn<\n      TParentData,\n      TName,\n      TOnSubmitAsync,\n      TFormOnSubmitAsync\n    >\n  >\n  /**\n   * A flag indicating whether the field is currently being validated.\n   */\n  isValidating: boolean\n}\n\nexport type AnyFieldMetaBase = FieldMetaBase<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\nexport type FieldMetaDerived<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChangeAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnBlurAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n> = {\n  /**\n   * An array of errors related to the field value.\n   */\n  errors: Array<\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldValidateOrFn<TParentData, TName, TOnMount, TFormOnMount>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldValidateOrFn<TParentData, TName, TOnChange, TFormOnChange>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldAsyncValidateOrFn<\n          TParentData,\n          TName,\n          TOnChangeAsync,\n          TFormOnChangeAsync\n        >\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldValidateOrFn<TParentData, TName, TOnBlur, TFormOnBlur>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldAsyncValidateOrFn<\n          TParentData,\n          TName,\n          TOnBlurAsync,\n          TFormOnBlurAsync\n        >\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldValidateOrFn<TParentData, TName, TOnSubmit, TFormOnSubmit>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldAsyncValidateOrFn<\n          TParentData,\n          TName,\n          TOnSubmitAsync,\n          TFormOnSubmitAsync\n        >\n      >\n  >\n  /**\n   * A flag that is `true` if the field's value has not been modified by the user. Opposite of `isDirty`.\n   */\n  isPristine: boolean\n}\n\nexport type AnyFieldMetaDerived = FieldMetaDerived<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\n/**\n * An object type representing the metadata of a field in a form.\n */\nexport type FieldMeta<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChangeAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnBlurAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n> = FieldMetaBase<\n  TParentData,\n  TName,\n  TData,\n  TOnMount,\n  TOnChange,\n  TOnChangeAsync,\n  TOnBlur,\n  TOnBlurAsync,\n  TOnSubmit,\n  TOnSubmitAsync,\n  TFormOnMount,\n  TFormOnChange,\n  TFormOnChangeAsync,\n  TFormOnBlur,\n  TFormOnBlurAsync,\n  TFormOnSubmit,\n  TFormOnSubmitAsync\n> &\n  FieldMetaDerived<\n    TParentData,\n    TName,\n    TData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TFormOnMount,\n    TFormOnChange,\n    TFormOnChangeAsync,\n    TFormOnBlur,\n    TFormOnBlurAsync,\n    TFormOnSubmit,\n    TFormOnSubmitAsync\n  >\n\nexport type AnyFieldMeta = FieldMeta<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\n/**\n * An object type representing the state of a field.\n */\nexport type FieldState<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChangeAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnBlurAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n> = {\n  /**\n   * The current value of the field.\n   */\n  value: TData\n  /**\n   * The current metadata of the field.\n   */\n  meta: FieldMeta<\n    TParentData,\n    TName,\n    TData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TFormOnMount,\n    TFormOnChange,\n    TFormOnChangeAsync,\n    TFormOnBlur,\n    TFormOnBlurAsync,\n    TFormOnSubmit,\n    TFormOnSubmitAsync\n  >\n}\n\n/**\n * @public\n *\n * A type representing the Field API with all generics set to `any` for convenience.\n */\nexport type AnyFieldApi = FieldApi<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\n/**\n * A class representing the API for managing a form field.\n *\n * Normally, you will not need to create a new `FieldApi` instance directly.\n * Instead, you will use a framework hook/function like `useField` or `createField`\n * to create a new instance for you that uses your framework's reactivity model.\n * However, if you need to create a new instance manually, you can do so by calling\n * the `new FieldApi` constructor.\n */\nexport class FieldApi<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChangeAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnBlurAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnServer extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TParentSubmitMeta,\n> {\n  /**\n   * A reference to the form API instance.\n   */\n  form: FieldApiOptions<\n    TParentData,\n    TName,\n    TData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TFormOnMount,\n    TFormOnChange,\n    TFormOnChangeAsync,\n    TFormOnBlur,\n    TFormOnBlurAsync,\n    TFormOnSubmit,\n    TFormOnSubmitAsync,\n    TFormOnServer,\n    TParentSubmitMeta\n  >['form']\n  /**\n   * The field name.\n   */\n  name!: DeepKeys<TParentData>\n  /**\n   * The field options.\n   */\n  options: FieldApiOptions<\n    TParentData,\n    TName,\n    TData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TFormOnMount,\n    TFormOnChange,\n    TFormOnChangeAsync,\n    TFormOnBlur,\n    TFormOnBlurAsync,\n    TFormOnSubmit,\n    TFormOnSubmitAsync,\n    TFormOnServer,\n    TParentSubmitMeta\n  > = {} as any\n  /**\n   * The field state store.\n   */\n  store!: Derived<\n    FieldState<\n      TParentData,\n      TName,\n      TData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TFormOnMount,\n      TFormOnChange,\n      TFormOnChangeAsync,\n      TFormOnBlur,\n      TFormOnBlurAsync,\n      TFormOnSubmit,\n      TFormOnSubmitAsync\n    >\n  >\n  /**\n   * The current field state.\n   */\n  get state() {\n    return this.store.state\n  }\n  timeoutIds: Record<ValidationCause, ReturnType<typeof setTimeout> | null>\n\n  /**\n   * Initializes a new `FieldApi` instance.\n   */\n  constructor(\n    opts: FieldApiOptions<\n      TParentData,\n      TName,\n      TData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TFormOnMount,\n      TFormOnChange,\n      TFormOnChangeAsync,\n      TFormOnBlur,\n      TFormOnBlurAsync,\n      TFormOnSubmit,\n      TFormOnSubmitAsync,\n      TFormOnServer,\n      TParentSubmitMeta\n    >,\n  ) {\n    this.form = opts.form as never\n    this.name = opts.name as never\n    this.timeoutIds = {} as Record<ValidationCause, never>\n    if (opts.defaultValue !== undefined) {\n      this.form.setFieldValue(this.name, opts.defaultValue as never, {\n        dontUpdateMeta: true,\n      })\n    }\n\n    this.store = new Derived({\n      deps: [this.form.store],\n      fn: () => {\n        const value = this.form.getFieldValue(this.name)\n        const meta = this.form.getFieldMeta(this.name) ?? {\n          ...defaultFieldMeta,\n          ...opts.defaultMeta,\n        }\n\n        return {\n          value,\n          meta,\n        } as FieldState<\n          TParentData,\n          TName,\n          TData,\n          TOnMount,\n          TOnChange,\n          TOnChangeAsync,\n          TOnBlur,\n          TOnBlurAsync,\n          TOnSubmit,\n          TOnSubmitAsync,\n          TFormOnMount,\n          TFormOnChange,\n          TFormOnChangeAsync,\n          TFormOnBlur,\n          TFormOnBlurAsync,\n          TFormOnSubmit,\n          TFormOnSubmitAsync\n        >\n      },\n    })\n\n    this.options = opts as never\n  }\n\n  /**\n   * @private\n   */\n  runValidator<\n    TValue extends TStandardSchemaValidatorValue<TData> & {\n      fieldApi: AnyFieldApi\n    },\n    TType extends 'validate' | 'validateAsync',\n  >(props: {\n    validate: TType extends 'validate'\n      ? FieldValidateOrFn<any, any, any>\n      : FieldAsyncValidateOrFn<any, any, any>\n    value: TValue\n    type: TType\n    // When `api` is 'field', the return type cannot be `FormValidationError`\n  }): unknown {\n    if (isStandardSchemaValidator(props.validate)) {\n      return standardSchemaValidators[props.type](\n        props.value,\n        props.validate,\n      ) as never\n    }\n\n    return (props.validate as FieldValidateFn<any, any>)(props.value) as never\n  }\n\n  /**\n   * Mounts the field instance to the form.\n   */\n  mount = () => {\n    const cleanup = this.store.mount()\n\n    const info = this.getInfo()\n    info.instance = this as never\n\n    this.update(this.options as never)\n    const { onMount } = this.options.validators || {}\n\n    if (onMount) {\n      const error = this.runValidator({\n        validate: onMount,\n        value: {\n          value: this.state.value,\n          fieldApi: this,\n          validationSource: 'field',\n        },\n        type: 'validate',\n      })\n      if (error) {\n        this.setMeta(\n          (prev) =>\n            ({\n              ...prev,\n              // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n              errorMap: { ...prev?.errorMap, onMount: error },\n            }) as never,\n        )\n      }\n    }\n\n    this.options.listeners?.onMount?.({\n      value: this.state.value,\n      fieldApi: this,\n    })\n\n    return cleanup\n  }\n\n  /**\n   * Updates the field instance with new options.\n   */\n  update = (\n    opts: FieldApiOptions<\n      TParentData,\n      TName,\n      TData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TFormOnMount,\n      TFormOnChange,\n      TFormOnChangeAsync,\n      TFormOnBlur,\n      TFormOnBlurAsync,\n      TFormOnSubmit,\n      TFormOnSubmitAsync,\n      TFormOnServer,\n      TParentSubmitMeta\n    >,\n  ) => {\n    // Default Value\n\n    if (this.state.value === undefined) {\n      const formDefault = getBy(opts.form.options.defaultValues, opts.name)\n\n      if (opts.defaultValue !== undefined) {\n        this.setValue(opts.defaultValue as never, {\n          dontUpdateMeta: true,\n        })\n      } else if (formDefault !== undefined) {\n        this.setValue(formDefault as never, {\n          dontUpdateMeta: true,\n        })\n      }\n    }\n\n    // Default Meta\n    if (this.form.getFieldMeta(this.name) === undefined) {\n      this.setMeta(this.state.meta)\n    }\n\n    this.options = opts as never\n    this.name = opts.name\n  }\n\n  /**\n   * Gets the current field value.\n   * @deprecated Use `field.state.value` instead.\n   */\n  getValue = (): TData => {\n    return this.form.getFieldValue(this.name) as TData\n  }\n\n  /**\n   * Sets the field value and run the `change` validator.\n   */\n  setValue = (updater: Updater<TData>, options?: UpdateMetaOptions) => {\n    this.form.setFieldValue(this.name, updater as never, options)\n\n    this.options.listeners?.onChange?.({\n      value: this.state.value,\n      fieldApi: this,\n    })\n\n    this.validate('change')\n  }\n\n  getMeta = () => this.store.state.meta\n\n  /**\n   * Sets the field metadata.\n   */\n  setMeta = (\n    updater: Updater<\n      FieldMeta<\n        TParentData,\n        TName,\n        TData,\n        TOnMount,\n        TOnChange,\n        TOnChangeAsync,\n        TOnBlur,\n        TOnBlurAsync,\n        TOnSubmit,\n        TOnSubmitAsync,\n        TFormOnMount,\n        TFormOnChange,\n        TFormOnChangeAsync,\n        TFormOnBlur,\n        TFormOnBlurAsync,\n        TFormOnSubmit,\n        TFormOnSubmitAsync\n      >\n    >,\n  ) => this.form.setFieldMeta(this.name, updater)\n\n  /**\n   * Gets the field information object.\n   */\n  getInfo = () => this.form.getFieldInfo(this.name)\n\n  /**\n   * Pushes a new value to the field.\n   */\n  pushValue = (\n    value: TData extends any[] ? TData[number] : never,\n    opts?: UpdateMetaOptions,\n  ) => {\n    this.form.pushFieldValue(this.name, value as any, opts)\n\n    this.options.listeners?.onChange?.({\n      value: this.state.value,\n      fieldApi: this,\n    })\n  }\n\n  /**\n   * Inserts a value at the specified index, shifting the subsequent values to the right.\n   */\n  insertValue = (\n    index: number,\n    value: TData extends any[] ? TData[number] : never,\n    opts?: UpdateMetaOptions,\n  ) => {\n    this.form.insertFieldValue(this.name, index, value as any, opts)\n\n    this.options.listeners?.onChange?.({\n      value: this.state.value,\n      fieldApi: this,\n    })\n  }\n\n  /**\n   * Replaces a value at the specified index.\n   */\n  replaceValue = (\n    index: number,\n    value: TData extends any[] ? TData[number] : never,\n    opts?: UpdateMetaOptions,\n  ) => {\n    this.form.replaceFieldValue(this.name, index, value as any, opts)\n\n    this.options.listeners?.onChange?.({\n      value: this.state.value,\n      fieldApi: this,\n    })\n  }\n\n  /**\n   * Removes a value at the specified index.\n   */\n  removeValue = (index: number, opts?: UpdateMetaOptions) => {\n    this.form.removeFieldValue(this.name, index, opts)\n\n    this.options.listeners?.onChange?.({\n      value: this.state.value,\n      fieldApi: this,\n    })\n  }\n\n  /**\n   * Swaps the values at the specified indices.\n   */\n  swapValues = (aIndex: number, bIndex: number, opts?: UpdateMetaOptions) => {\n    this.form.swapFieldValues(this.name, aIndex, bIndex, opts)\n\n    this.options.listeners?.onChange?.({\n      value: this.state.value,\n      fieldApi: this,\n    })\n  }\n\n  /**\n   * Moves the value at the first specified index to the second specified index.\n   */\n  moveValue = (aIndex: number, bIndex: number, opts?: UpdateMetaOptions) => {\n    this.form.moveFieldValues(this.name, aIndex, bIndex, opts)\n\n    this.options.listeners?.onChange?.({\n      value: this.state.value,\n      fieldApi: this,\n    })\n  }\n\n  /**\n   * @private\n   */\n  getLinkedFields = (cause: ValidationCause) => {\n    const fields = Object.values(this.form.fieldInfo) as FieldInfo<any>[]\n\n    const linkedFields: AnyFieldApi[] = []\n    for (const field of fields) {\n      if (!field.instance) continue\n      const { onChangeListenTo, onBlurListenTo } =\n        field.instance.options.validators || {}\n      if (\n        cause === 'change' &&\n        onChangeListenTo?.includes(this.name as string)\n      ) {\n        linkedFields.push(field.instance)\n      }\n      if (cause === 'blur' && onBlurListenTo?.includes(this.name as string)) {\n        linkedFields.push(field.instance)\n      }\n    }\n\n    return linkedFields\n  }\n\n  /**\n   * @private\n   */\n  validateSync = (\n    cause: ValidationCause,\n    errorFromForm: ValidationErrorMap,\n  ) => {\n    const validates = getSyncValidatorArray(cause, this.options)\n\n    const linkedFields = this.getLinkedFields(cause)\n    const linkedFieldValidates = linkedFields.reduce(\n      (acc, field) => {\n        const fieldValidates = getSyncValidatorArray(cause, field.options)\n        fieldValidates.forEach((validate) => {\n          ;(validate as any).field = field\n        })\n        return acc.concat(fieldValidates as never)\n      },\n      [] as Array<\n        SyncValidator<any> & {\n          field: AnyFieldApi\n        }\n      >,\n    )\n\n    // Needs type cast as eslint errantly believes this is always falsy\n    let hasErrored = false as boolean\n\n    batch(() => {\n      const validateFieldFn = (\n        field: AnyFieldApi,\n        validateObj: SyncValidator<any>,\n      ) => {\n        const errorMapKey = getErrorMapKey(validateObj.cause)\n\n        const error =\n          /*\n            If `validateObj.validate` is `undefined`, then the field doesn't have\n            a validator for this event, but there still could be an error that\n            needs to be cleaned up related to the current event left by the\n            form's validator.\n          */\n          validateObj.validate\n            ? normalizeError(\n                field.runValidator({\n                  validate: validateObj.validate,\n                  value: {\n                    value: field.store.state.value,\n                    validationSource: 'field',\n                    fieldApi: field,\n                  },\n                  type: 'validate',\n                }),\n              )\n            : errorFromForm[errorMapKey]\n\n        if (field.state.meta.errorMap[errorMapKey] !== error) {\n          field.setMeta((prev) => ({\n            ...prev,\n            errorMap: {\n              ...prev.errorMap,\n              [getErrorMapKey(validateObj.cause)]:\n                // Prefer the error message from the field validators if they exist\n                error ? error : errorFromForm[errorMapKey],\n            },\n          }))\n        }\n        if (error || errorFromForm[errorMapKey]) {\n          hasErrored = true\n        }\n      }\n\n      for (const validateObj of validates) {\n        validateFieldFn(this, validateObj)\n      }\n      for (const fieldValitateObj of linkedFieldValidates) {\n        if (!fieldValitateObj.validate) continue\n        validateFieldFn(fieldValitateObj.field, fieldValitateObj)\n      }\n    })\n\n    /**\n     *  when we have an error for onSubmit in the state, we want\n     *  to clear the error as soon as the user enters a valid value in the field\n     */\n    const submitErrKey = getErrorMapKey('submit')\n\n    if (\n      this.state.meta.errorMap[submitErrKey] &&\n      cause !== 'submit' &&\n      !hasErrored\n    ) {\n      this.setMeta((prev) => ({\n        ...prev,\n        errorMap: {\n          ...prev.errorMap,\n          [submitErrKey]: undefined,\n        },\n      }))\n    }\n\n    return { hasErrored }\n  }\n\n  /**\n   * @private\n   */\n  validateAsync = async (\n    cause: ValidationCause,\n    formValidationResultPromise: Promise<\n      FieldErrorMapFromValidator<\n        TParentData,\n        TName,\n        TData,\n        TOnMount,\n        TOnChange,\n        TOnChangeAsync,\n        TOnBlur,\n        TOnBlurAsync,\n        TOnSubmit,\n        TOnSubmitAsync\n      >\n    >,\n  ) => {\n    const validates = getAsyncValidatorArray(cause, this.options)\n\n    // Get the field-specific error messages that are coming from the form's validator\n    const asyncFormValidationResults = await formValidationResultPromise\n\n    const linkedFields = this.getLinkedFields(cause)\n    const linkedFieldValidates = linkedFields.reduce(\n      (acc, field) => {\n        const fieldValidates = getAsyncValidatorArray(cause, field.options)\n        fieldValidates.forEach((validate) => {\n          ;(validate as any).field = field\n        })\n        return acc.concat(fieldValidates as never)\n      },\n      [] as Array<\n        AsyncValidator<any> & {\n          field: AnyFieldApi\n        }\n      >,\n    )\n\n    if (!this.state.meta.isValidating) {\n      this.setMeta((prev) => ({ ...prev, isValidating: true }))\n    }\n\n    for (const linkedField of linkedFields) {\n      linkedField.setMeta((prev) => ({ ...prev, isValidating: true }))\n    }\n\n    /**\n     * We have to use a for loop and generate our promises this way, otherwise it won't be sync\n     * when there are no validators needed to be run\n     */\n    const validatesPromises: Promise<ValidationError | undefined>[] = []\n    const linkedPromises: Promise<ValidationError | undefined>[] = []\n\n    const validateFieldAsyncFn = (\n      field: AnyFieldApi,\n      validateObj: AsyncValidator<any>,\n      promises: Promise<ValidationError | undefined>[],\n    ) => {\n      const errorMapKey = getErrorMapKey(validateObj.cause)\n      const fieldValidatorMeta = field.getInfo().validationMetaMap[errorMapKey]\n\n      fieldValidatorMeta?.lastAbortController.abort()\n      const controller = new AbortController()\n\n      this.getInfo().validationMetaMap[errorMapKey] = {\n        lastAbortController: controller,\n      }\n\n      promises.push(\n        new Promise<ValidationError | undefined>(async (resolve) => {\n          let rawError!: ValidationError | undefined\n          try {\n            rawError = await new Promise((rawResolve, rawReject) => {\n              if (this.timeoutIds[validateObj.cause]) {\n                clearTimeout(this.timeoutIds[validateObj.cause]!)\n              }\n\n              this.timeoutIds[validateObj.cause] = setTimeout(async () => {\n                if (controller.signal.aborted) return rawResolve(undefined)\n                try {\n                  rawResolve(\n                    await this.runValidator({\n                      validate: validateObj.validate,\n                      value: {\n                        value: field.store.state.value,\n                        fieldApi: field,\n                        signal: controller.signal,\n                        validationSource: 'field',\n                      },\n                      type: 'validateAsync',\n                    }),\n                  )\n                } catch (e) {\n                  rawReject(e)\n                }\n              }, validateObj.debounceMs)\n            })\n          } catch (e: unknown) {\n            rawError = e as ValidationError\n          }\n          if (controller.signal.aborted) return resolve(undefined)\n          const error = normalizeError(rawError)\n          const fieldErrorFromForm =\n            asyncFormValidationResults[this.name]?.[errorMapKey]\n          const fieldError = error || fieldErrorFromForm\n          field.setMeta((prev) => {\n            return {\n              ...prev,\n              errorMap: {\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                ...prev?.errorMap,\n                [errorMapKey]: fieldError,\n              },\n            }\n          })\n\n          resolve(fieldError)\n        }),\n      )\n    }\n\n    // TODO: Dedupe this logic to reduce bundle size\n    for (const validateObj of validates) {\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!validateObj.validate) continue\n      validateFieldAsyncFn(this, validateObj, validatesPromises)\n    }\n    for (const fieldValitateObj of linkedFieldValidates) {\n      if (!fieldValitateObj.validate) continue\n      validateFieldAsyncFn(\n        fieldValitateObj.field,\n        fieldValitateObj,\n        linkedPromises,\n      )\n    }\n\n    let results: ValidationError[] = []\n    if (validatesPromises.length || linkedPromises.length) {\n      results = await Promise.all(validatesPromises)\n      await Promise.all(linkedPromises)\n    }\n\n    this.setMeta((prev) => ({ ...prev, isValidating: false }))\n\n    for (const linkedField of linkedFields) {\n      linkedField.setMeta((prev) => ({ ...prev, isValidating: false }))\n    }\n\n    return results.filter(Boolean)\n  }\n\n  /**\n   * Validates the field value.\n   */\n  validate = (\n    cause: ValidationCause,\n    opts?: { skipFormValidation?: boolean },\n  ): ValidationError[] | Promise<ValidationError[]> => {\n    // If the field is pristine, do not validate\n    if (!this.state.meta.isTouched) return []\n\n    // Attempt to sync validate first\n    const { fieldsErrorMap } = opts?.skipFormValidation\n      ? { fieldsErrorMap: {} as never }\n      : this.form.validateSync(cause)\n    const { hasErrored } = this.validateSync(\n      cause,\n      fieldsErrorMap[this.name] ?? {},\n    )\n\n    if (hasErrored && !this.options.asyncAlways) {\n      this.getInfo().validationMetaMap[\n        getErrorMapKey(cause)\n      ]?.lastAbortController.abort()\n      return this.state.meta.errors\n    }\n\n    // No error? Attempt async validation\n    const formValidationResultPromise = opts?.skipFormValidation\n      ? Promise.resolve({})\n      : this.form.validateAsync(cause)\n    return this.validateAsync(cause, formValidationResultPromise)\n  }\n\n  /**\n   * Handles the change event.\n   */\n  handleChange = (updater: Updater<TData>) => {\n    this.setValue(updater)\n  }\n\n  /**\n   * Handles the blur event.\n   */\n  handleBlur = () => {\n    const prevTouched = this.state.meta.isTouched\n    if (!prevTouched) {\n      this.setMeta((prev) => ({ ...prev, isTouched: true }))\n      this.validate('change')\n    }\n    if (!this.state.meta.isBlurred) {\n      this.setMeta((prev) => ({ ...prev, isBlurred: true }))\n    }\n    this.validate('blur')\n\n    this.options.listeners?.onBlur?.({\n      value: this.state.value,\n      fieldApi: this,\n    })\n  }\n\n  /**\n   * Updates the field's errorMap\n   */\n  setErrorMap(errorMap: ValidationErrorMap) {\n    this.setMeta(\n      (prev) =>\n        ({\n          ...prev,\n          errorMap: {\n            ...prev.errorMap,\n            ...errorMap,\n          },\n        }) as never,\n    )\n  }\n}\n\nfunction normalizeError(rawError?: ValidationError) {\n  if (rawError) {\n    return rawError\n  }\n\n  return undefined\n}\n\nfunction getErrorMapKey(cause: ValidationCause) {\n  switch (cause) {\n    case 'submit':\n      return 'onSubmit'\n    case 'blur':\n      return 'onBlur'\n    case 'mount':\n      return 'onMount'\n    case 'server':\n      return 'onServer'\n    case 'change':\n    default:\n      return 'onChange'\n  }\n}\n"],"names":["opts","getBy","getSyncValidatorArray","batch","getAsyncValidatorArray","Derived","defaultFieldMeta","isStandardSchemaValidator","standardSchemaValidators"],"mappings":"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"}