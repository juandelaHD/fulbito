{"version":3,"file":"standardSchemaValidator.js","sources":["../../src/standardSchemaValidator.ts"],"sourcesContent":["import type { ValidationSource } from './types'\n\nexport type TStandardSchemaValidatorValue<TData> = {\n  value: TData\n  validationSource: ValidationSource\n}\n\nfunction prefixSchemaToErrors(issues: readonly StandardSchemaV1Issue[]) {\n  const schema = new Map<string, StandardSchemaV1Issue[]>()\n\n  for (const issue of issues) {\n    const path = [...(issue.path ?? [])]\n      .map((segment) => {\n        const normalizedSegment =\n          typeof segment === 'object' ? segment.key : segment\n        return typeof normalizedSegment === 'number'\n          ? `[${normalizedSegment}]`\n          : normalizedSegment\n      })\n      .join('.')\n      .replace(/\\.\\[/g, '[')\n\n    schema.set(path, (schema.get(path) ?? []).concat(issue))\n  }\n\n  return Object.fromEntries(schema)\n}\n\nconst defaultFieldTransformer = (issues: readonly StandardSchemaV1Issue[]) =>\n  issues\n\nconst defaultFormTransformer = (issues: readonly StandardSchemaV1Issue[]) => {\n  const schemaErrors = prefixSchemaToErrors(issues)\n  return {\n    form: schemaErrors,\n    fields: schemaErrors,\n  }\n}\n\nconst transformIssues = (\n  validationSource: 'form' | 'field',\n  issues: readonly StandardSchemaV1Issue[],\n) =>\n  validationSource === 'form'\n    ? defaultFormTransformer(issues)\n    : defaultFieldTransformer(issues)\n\nexport const standardSchemaValidators = {\n  validate(\n    { value, validationSource }: TStandardSchemaValidatorValue<unknown>,\n    schema: StandardSchemaV1,\n  ) {\n    const result = schema['~standard'].validate(value)\n\n    if (result instanceof Promise) {\n      throw new Error('async function passed to sync validator')\n    }\n\n    if (!result.issues) return\n\n    return transformIssues(validationSource, result.issues)\n  },\n  async validateAsync(\n    { value, validationSource }: TStandardSchemaValidatorValue<unknown>,\n    schema: StandardSchemaV1,\n  ) {\n    const result = await schema['~standard'].validate(value)\n\n    if (!result.issues) return\n\n    return transformIssues(validationSource, result.issues)\n  },\n}\n\nexport const isStandardSchemaValidator = (\n  validator: unknown,\n): validator is StandardSchemaV1 =>\n  !!validator && '~standard' in (validator as object)\n\n/**\n * The Standard Schema interface.\n */\nexport type StandardSchemaV1<Input = unknown, Output = Input> = {\n  /**\n   * The Standard Schema properties.\n   */\n  readonly '~standard': StandardSchemaV1Props<Input, Output>\n}\n\n/**\n * The Standard Schema properties interface.\n */\ninterface StandardSchemaV1Props<Input = unknown, Output = Input> {\n  /**\n   * The version number of the standard.\n   */\n  readonly version: 1\n  /**\n   * The vendor name of the schema library.\n   */\n  readonly vendor: string\n  /**\n   * Validates unknown input values.\n   */\n  readonly validate: (\n    value: unknown,\n  ) => StandardSchemaV1Result<Output> | Promise<StandardSchemaV1Result<Output>>\n  /**\n   * Inferred types associated with the schema.\n   */\n  readonly types?: StandardSchemaV1Types<Input, Output> | undefined\n}\n/**\n * The result interface of the validate function.\n */\ntype StandardSchemaV1Result<Output> =\n  | StandardSchemaV1SuccessResult<Output>\n  | StandardSchemaV1FailureResult\n/**\n * The result interface if validation succeeds.\n */\ninterface StandardSchemaV1SuccessResult<Output> {\n  /**\n   * The typed output value.\n   */\n  readonly value: Output\n  /**\n   * The non-existent issues.\n   */\n  readonly issues?: undefined\n}\n/**\n * The result interface if validation fails.\n */\ninterface StandardSchemaV1FailureResult {\n  /**\n   * The issues of failed validation.\n   */\n  readonly issues: ReadonlyArray<StandardSchemaV1Issue>\n}\n/**\n * The issue interface of the failure output.\n */\nexport interface StandardSchemaV1Issue {\n  /**\n   * The error message of the issue.\n   */\n  readonly message: string\n  /**\n   * The path of the issue, if any.\n   */\n  readonly path?:\n    | ReadonlyArray<PropertyKey | StandardSchemaV1PathSegment>\n    | undefined\n}\n/**\n * The path segment interface of the issue.\n */\ninterface StandardSchemaV1PathSegment {\n  /**\n   * The key representing a path segment.\n   */\n  readonly key: PropertyKey\n}\n/**\n * The Standard Schema types interface.\n */\ninterface StandardSchemaV1Types<Input = unknown, Output = Input> {\n  /**\n   * The input type of the schema.\n   */\n  readonly input: Input\n  /**\n   * The output type of the schema.\n   */\n  readonly output: Output\n}\n"],"names":[],"mappings":"AAOA,SAAS,qBAAqB,QAA0C;AAChE,QAAA,6BAAa,IAAqC;AAExD,aAAW,SAAS,QAAQ;AACpB,UAAA,OAAO,CAAC,GAAI,MAAM,QAAQ,CAAA,CAAG,EAChC,IAAI,CAAC,YAAY;AAChB,YAAM,oBACJ,OAAO,YAAY,WAAW,QAAQ,MAAM;AAC9C,aAAO,OAAO,sBAAsB,WAChC,IAAI,iBAAiB,MACrB;AAAA,IAAA,CACL,EACA,KAAK,GAAG,EACR,QAAQ,SAAS,GAAG;AAEhB,WAAA,IAAI,OAAO,OAAO,IAAI,IAAI,KAAK,CAAC,GAAG,OAAO,KAAK,CAAC;AAAA,EAAA;AAGlD,SAAA,OAAO,YAAY,MAAM;AAClC;AAEA,MAAM,0BAA0B,CAAC,WAC/B;AAEF,MAAM,yBAAyB,CAAC,WAA6C;AACrE,QAAA,eAAe,qBAAqB,MAAM;AACzC,SAAA;AAAA,IACL,MAAM;AAAA,IACN,QAAQ;AAAA,EACV;AACF;AAEA,MAAM,kBAAkB,CACtB,kBACA,WAEA,qBAAqB,SACjB,uBAAuB,MAAM,IAC7B,wBAAwB,MAAM;AAE7B,MAAM,2BAA2B;AAAA,EACtC,SACE,EAAE,OAAO,iBAAA,GACT,QACA;AACA,UAAM,SAAS,OAAO,WAAW,EAAE,SAAS,KAAK;AAEjD,QAAI,kBAAkB,SAAS;AACvB,YAAA,IAAI,MAAM,yCAAyC;AAAA,IAAA;AAGvD,QAAA,CAAC,OAAO,OAAQ;AAEb,WAAA,gBAAgB,kBAAkB,OAAO,MAAM;AAAA,EACxD;AAAA,EACA,MAAM,cACJ,EAAE,OAAO,iBAAA,GACT,QACA;AACA,UAAM,SAAS,MAAM,OAAO,WAAW,EAAE,SAAS,KAAK;AAEnD,QAAA,CAAC,OAAO,OAAQ;AAEb,WAAA,gBAAgB,kBAAkB,OAAO,MAAM;AAAA,EAAA;AAE1D;AAEO,MAAM,4BAA4B,CACvC,cAEA,CAAC,CAAC,aAAa,eAAgB;"}